#!/usr/bin/ruby -w
################################################################################
# (c) Copyright 2007-2011 Alces Software Ltd & Stephen F Norledge.             #
#                                                                              #
# HPC Cluster Toolkit                                                          #
#                                                                              #
# This file/package is part of the HPC Cluster Toolkit                         #
#                                                                              #
# This is free software: you can redistribute it and/or modify it under        #
# the terms of the GNU Affero General Public License as published by the Free  #
# Software Foundation, either version 3 of the License, or (at your option)    #
# any later version.                                                           #
#                                                                              #
# This file is distributed in the hope that it will be useful, but WITHOUT     #
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or        #
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License #
# for more details.                                                            #
#                                                                              #
# You should have received a copy of the GNU Affero General Public License     #
# along with this product.  If not, see <http://www.gnu.org/licenses/>.        #
#                                                                              #
# For more information on Alces Software, please visit:                        #
# http://www.alces-software.org/                                               #
#                                                                              #
################################################################################

require 'fileutils'

if `whoami`.chomp != 'root'
  STDERR.puts "Must be run as superuser"
  exit 1
end

module Alces
  class Onesis

    attr_reader :image_name,:node
    
    BASE_PATH="/var/lib/oneSIS/images/"
    EXCLUDES=["/proc/","/sys"]

    CLEAN_DIRS=["/tmp","/scratch","/var/tmp"]

    PXE_BASE="/var/lib/tftpboot/"

    class InvalidImageName < StandardError; end
    class FilesystemError < StandardError; end

    def initialize(image_name,node)
      @image_name=image_name
      @node=node
      validate_image_name
    end

    def image_path
      ::File::join(BASE_PATH,image_name)
    end

    def deploy!
      copy_rootfs
      clean!
      pxe_install
      prepare
      cobbler_setup
    end

    def copy_rootfs
      message "Copying root fs from #{node}"
   
      node_alive?(node)

      make_image_path

      excludeline=(EXCLUDES.collect { |exclude| "--exclude #{exclude}" }).join(" ")
      cmd="copy-rootfs --remote #{node} #{excludeline} #{image_path}"
     
      raise "Copy root failed" unless monitor_command(cmd)
    end 

    def clean!
      message "Cleaning new root image", 1
      CLEAN_DIRS.each do |dir|
	      dir=dir.gsub(/\/$/,'') #strip trailing slash
        unless ::File::symlink? ::File::join(image_path,dir)
          message "Scrubbing #{dir}", 2
	        monitor_command("rm --one-file-system -rf #{::File::join(image_path,dir,'/.')}")
        end
      end
      message "Scrubbing /var/run"
      monitor_command("find #{::File::join(image_path,"var/run")} ! -type d -exec rm {} \\;")
      message "Scrubbing network configs"
      monitor_command("rm -rf #{::File::join(image_path,"etc/sysconfig/network-scripts/ifcfg-eth*")}")
    end

    def kernel_file
      @kernel_file ||= (
        kernels=::Dir::glob(::File::join(image_path,'boot','/vmlinu*'))
        raise "Unable to determine kernel file" if kernels.empty?
        kernels.first.gsub(/^#{image_path}/,"")
      )
    end

    def initrd_file
      @initrd_file ||= (
        initrds=::Dir::glob(::File::join(image_path,'boot','/initrd*'))
        raise "Unable to determine initrd file" if initrds.empty?
        initrds.first.gsub(/^#{image_path}/,"")
      )
    end

    def kernel_version
      @kernel_version ||= (
        kernel_versions=::Dir::glob(::File::join(image_path,'lib','modules/*')).collect { |x| kernel_file.to_s.match(/#{::File::split(x).last}/).to_s }
        kernel_versions.delete_if {|x| x.empty? }
        raise "Unable to determine kernel version" if kernel_versions.empty?
        ver=kernel_versions.compact.first
        raise "Failed to determine correct kernel version" if ver.to_s.empty?
        ver
      )
    end

    def initramfs_file
      @initramfs_file ||= (
        make_initramfs
      )
    end

    def pxe_install
      message "Installing kernel/initramfs to PXE", 1
      ::File::delete(pxe_kernel_target) rescue nil
      ::File::delete(pxe_initrd_target) rescue nil
      ::FileUtils::cp(kernel_file,pxe_kernel_target)
      ::FileUtils::cp(initramfs_file,pxe_initrd_target)
      raise "PXE install failed" unless (::File::exists?(pxe_kernel_target)) && (::File::exists?(pxe_initrd_target))
    end

    def prepare
      message "Preparing Image",1
      message "Setting READONLY root",2
      raise "Failed to set readonly root" unless system("sed -i.onesis 's/^READONLY=.*/READONLY=yes/g' #{::File::join(image_path,"etc/sysconfig/readonly-root")}")
      message "Preparing rwtab",2
      rwtab=::File::join(image_path,"etc/rwtab")
      ::FileUtils::mv(rwtab,"#{rwtab}.onesis") rescue nil
      raise "Failed to move rwtab" if ::File::exists? rwtab
      message "Installing sysimage config",2
      sysimage_target=::File::join(image_path,"etc/sysimage.conf")
      ::FileUtils::cp(sysimage,sysimage_target)
      raise "Install sysimage config failed" unless ::File::exists? sysimage_target
      message "Running OneSIS prepare",2
      raise "Failed to run onesis prepare" unless monitor_command("mk-sysimage -c #{sysimage} -p #{patchfile}  #{image_path}")
    end

    def cobbler_setup
      message "Creating cobbler entries",1
      monitor_command "cobbler profile remove --name \"#{image_name}-onesis\""
      monitor_command "cobbler distro remove --name \"#{image_name}-onesis\""
      message "Adding cobbler distro",2
      raise "Failed to add cobbler distro" unless monitor_command("cobbler distro add --name \"#{image_name}-onesis\" --kernel=\"#{pxe_kernel_target}\" --initrd=\"#{pxe_initrd_target}\" --arch=\"#{arch}\" --breed=\"#{breed}\" --kopts=\"root=\\$server:#{image_path}\"")
      message "Adding cobbler profile",2
      raise "Failed to add cobbler profile" unless monitor_command("cobbler profile add --name \"#{image_name}-onesis\" --distro \"#{image_name}-onesis\" --dhcp-tag=\"diskless\" --ksmeta=\"nfsroot=#{image_path}\" --kopts=\"selinux=0\"")
      message "Syncing cobbler",2
      monitor_command "cobbler sync"
    end

    def pxe_kernel_target
      ::File::join(PXE_BASE,"vmlinuz-onesis-#{image_name}")
    end

    def pxe_initrd_target
      ::File::join(PXE_BASE,"initrd-onesis-#{image_name}")
    end

    def arch
      "x86_64"
    end

    def breed
      "redhat"
    end

    private

    def message(message,level=1)
      case level
      when 1
        puts message
      when 2
        puts "  - #{message}"
      else
        puts "    * #{message}"
      end
    end

    def validate_image_name
      raise InvalidImageName if image_name =~ /[^\w_\.\-]+/
    end

    def make_image_path
      ::FileUtils::mkdir_p image_path rescue nil
      raise FilesystemError, "Can't create image path #{image_path}" unless ::File::directory? image_path 
    end

    def node_alive?(node)
      raise "Unable to contact source node #{node}" unless system "ping -c 1 #{node} >  /dev/null 2>&1"
    end

    def make_initramfs
      message "Making initRamFS"
      drivers=["igb","e1000","e1000e","forcedeth","tg3","qib","mlx4-ib","ib-mthca","ib-ipoib","uhci-hcd","ohci-hcd","ehci-hcd","pcnet32","ixgbe","ixgb","ahci"]
      image_size=8192
      dhcp_retries=0 #0 is infinate
      config="/etc/oneSIS/initramfs.conf"
      out_file="/tmp/initrd-onesis"

      ::File::delete(out_file) rescue nil
      raise "Target file already exists" if ::File::exists? out_file

      driver_s=(drivers.collect {|d| "-w #{d}"}).join(" ")
      cmd="mk-initramfs-oneSIS -f -s #{image_size} #{driver_s} -dr #{dhcp_retries} -c #{config} -b #{image_path} #{out_file} #{kernel_version}"
      raise "Make initrd Failed" unless monitor_command(cmd)
      out_file
    end

   
    def monitor_command(cmd)
      message("Executing command #{cmd}")
      output="/tmp/onesisout.#{$$}"
      cmd="#{cmd} &> #{output}"
      puts cmd.inspect
      t=Thread.new(cmd) {|cmd| system cmd}
      sleep 2
      f=::File::open(output)
      while t.alive? do
        buff=f.read
        puts buff unless buff.empty?
        sleep 0.1
      end
      puts f.read
      f.close
      ::File::delete(output)
      message("Command Execution complete")
      t.value
    end
   
    def sysimage
      sysimage=::File::expand_path(::File::join(::File::dirname(__FILE__),"../","vendor","diskless","sysimage.conf.rhel6"))
      raise "Can't find sysimage - #{sysimage}" unless ::File::exists? sysimage
      sysimage
    end

    def patchfile
      patchfile=::File::expand_path(::File::join(::File::dirname(__FILE__),"../","vendor","diskless","redhat-el-6.2.patch"))
      raise "Can't find patch file - #{patchfile}" unless ::File::exists? patchfile
      patchfile
    end
  end
end

image_name=ARGV[0]
source_node=ARGV[1]

def usage
  STDERR.puts "Usage: #{::File::basename(__FILE__)} <image_name> <source_node>"
  exit 1
end

usage if image_name.to_s.empty?
usage if source_node.to_s.empty?

newimage=Alces::Onesis.new(image_name,source_node)
newimage.deploy!
