<<DOC
: '
: NAME: ipmi-configurator
: SYNOPSIS: Configure local IPMI/BMC
: VERSION: 4.1.0
: '
DOC
################################################################################
# (c) Copyright 2007-2011 Alces Software Ltd & Stephen F Norledge.             #
#                                                                              #
# Alces HPC Software Toolkit                                                   #
#                                                                              #
# This file/package is part of Symphony                                        #
#                                                                              #
# Symphony is free software: you can redistribute it and/or modify it under    #
# the terms of the GNU Affero General Public License as published by the Free  #
# Software Foundation, either version 3 of the License, or (at your option)    #
# any later version.                                                           #
#                                                                              #
# Symphony is distributed in the hope that it will be useful, but WITHOUT      #
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or        #
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License #
# for more details.                                                            #
#                                                                              #
# You should have received a copy of the GNU Affero General Public License     #
# along with Symphony.  If not, see <http://www.gnu.org/licenses/>.            #
#                                                                              #
# For more information on the Symphony Toolkit, please visit:                  #
# https://github.com/alces-software/symphony                                       #
#                                                                              #
################################################################################
# Execute as ruby script if we're evaluating under bash
if [ "" ]; then 0; else eval 'alces_RUBY_EXEC "$@" || exit 1'; fi; end

if `whoami`.chomp != 'root'
  STDERR.puts "Must be run as superuser"
  exit 1
end

require 'getoptlong'
require 'fileutils'

opts = GetoptLong.new(
  [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
  [ '--config', '-f', GetoptLong::REQUIRED_ARGUMENT ],
  [ '--command', '-c', GetoptLong::REQUIRED_ARGUMENT ]
)

def usage
  puts "Synopsis"
  puts
  puts "alces ipmi-configurator: Configure systems ipmi interface"
  puts
  puts "Usage"
  puts
  puts "alces ipmi-configurator [OPTION]"
  puts
  puts " -h, --help:"
  puts "   show help"
  puts
  puts " --command, -c:"
  puts "   specify command [CONFIGURE]"
  puts
  puts " --config, -f:"
  puts "   specify redhat type config file (defaults to using local,shared and alces config files)" 
  puts
end

command=nil
config_files=['/var/lib/alces/nodeware/etc/ipmi.conf','/var/lib/alces/nodeware/etc/ifcfg-bmc','/etc/sysconfig/network-scripts/ifcfg-bmc', '/etc/sysconfig/network/ifcfg-bmc']

opts.each do |opt, arg|
  case opt
  when '--help'
    usage
    exit 0
  when '--command'
    command=arg
  when '--config'
    config_files << arg
  end
end

if command.to_s.empty?
  STDERR.puts "Please specify a command"
  usage
  exit 1
end

require 'yaml'
require 'fileutils'
require 'rubygems'

module Alces
  module IPMIConfigurator
    class IPMIConfigurator
    
      def initialize(config_files,options=nil)
        @config_files=config_files
        
        @options={
                  :copy_interface=>bmc_config['IPADDR_COPY'] || 'eth0',
                  :address=>bmc_config['IPADDR'] || nil,
                  :address_mask=>bmc_config['IPADDR_MASK'] || '10.11.1.X',
                  :netmask=>bmc_config['NETMASK'] || "",
                  :gateway=>bmc_config['GATEWAY'] || "",
                  :username=>bmc_config['USERNAME'] || 'admin',
                  :password=>bmc_config['PASSWORD'] || 'sqrt(s*w)',
                  :userid=>bmc_config['USER_ID'] || '2',
                  :lanchannel=>bmc_config['LAN_CHANNEL'] || '1',
                  :silent=>false}.merge(options || {})
      end

      def bmc_config
        @bmc_config ||= readconfig @config_files        
      end
      
      def target_address
        return @options[:address] unless @options[:address].nil?
        copy_address=get_interface_address(@options[:copy_interface]).split('.')
        mask=@options[:address_mask].split('.')
        target_address=[]
        mask.size.times do |time|
          source_quad=mask[time] 
          if source_quad =~ /^X/
            target_address << copy_address[time]
          else
            target_address << source_quad 
          end
        end
        target_address.join('.')
      end

      def target_netmask
        if @options[:netmask].to_s.empty?
          get_interface_netmask(@options[:copy_interface])
        else
          @options[:netmask]
        end
      end

      def target_gateway
        @options[:gateway]
      end

      def target_username
        @options[:username]
      end

      def target_password
        @options[:password]
      end
      
      def lanchannel
        @options[:lanchannel]
      end
      
      def userid
        @options[:userid]
      end

      def set_network
        begin
          start_modules
          puts "Setting IP address: #{target_address}" unless @options[:silent]
          set_static_src ? puts("OK") : puts("FAILED")
          set_address(target_address) 
          puts "Setting netmask: #{target_netmask}" unless @options[:silent]
          set_netmask(target_netmask) ? puts("OK") : puts("FAILED")
          puts "Setting gateway: #{target_gateway}" unless @options[:silent]
          set_gateway(target_gateway) ? puts("OK") : puts("FAILED")
          puts "Setting admin username: #{target_username}" unless @options[:silent]
          set_username(target_username) ? puts("OK") : puts("FAILED")
          puts "Setting admin password: #{str=''; target_password.size.times {str << 'X'}; str}" unless @options[:silent]
          set_password(target_password) ? puts("OK") : puts("FAILED")
        rescue Exception => e
          raise e
        ensure
          stop_modules
        end
      end

      private
      
      def readconfig(files)
        hsh={}
        files.each do |file|
          if ::File::exists? file
            str=File::read(file)
            str.split
            str.each_line do |keyvalue|
              unless keyvalue =~ /^#/
                splt=keyvalue.split("=")
                if splt.size == 2
                  hsh[splt.first]=splt.last.chomp
                end
              end
            end
          end
        end
        hsh
      end
      
      def get_interface_address(interface_name)
        begin
          address=`/sbin/ifconfig #{interface_name} | grep 'inet addr'`.split(":")[1].split[0]
          address=address.split('.')
          raise 'address not valid' unless address.size == 4
          address.join('.')
        rescue
          raise "Unable to determine address of interface '#{interface_name}'"
        end
      end
      def get_interface_netmask(interface_name)
        begin
          netmask=`/sbin/ifconfig #{interface_name} | grep 'inet addr'`.split(':')[3].chomp.split('.')
          raise 'netmask not valid' unless netmask.size == 4
          netmask.join('.')
        rescue
          raise "Unable to determine address of interface '#{interface_name}'"
        end
      end 

      def set_static_src
        ipmi_command "lan set #{lanchannel} ipsrc static"
      end

      def set_address(address)
        ipmi_command "lan set #{lanchannel} ipaddr #{address}" unless address.to_s.empty?
      end

      def set_netmask(netmask)
        ipmi_command "lan set #{lanchannel} netmask #{netmask}" unless netmask.to_s.empty?
      end

      def set_gateway(gateway)
        unless gateway.to_s.empty?
          ipmi_command "lan set #{lanchannel} defgw ipaddr #{gateway}"
        end
      end

      def set_username(username)
        ipmi_command "user set name #{userid} '#{username}'" unless username.to_s.empty?
      end

      def set_password(password)
        ipmi_command "user set password #{userid} '#{password}'" unless password.to_s.empty?
      end

      def ipmi_command(command)
        cmd="/usr/bin/ipmitool #{command}"
        result=system "#{cmd} &> /dev/null"
        #raise "Failure when executing command #{cmd}" unless result
        result
      end
      
      def start_modules
        unless system("service ipmi status &>/dev/null")
          if system("service ipmi start &>/dev/null")
            @started_modules=true
          else
            raise "Failed to start IPMI service"
          end
        end
      end
      
      def stop_modules
        if @started_modules
          unless system("service ipmi stop &>/dev/null")
            raise "Failed to stop IPMI service"
          end
        end
      end
    end

    class CLI
  
      VALID_COMMANDS=[:CONFIGURE]

      class InvalidCommand < StandardError; end
      class InvalidOption < StandardError; end

      def initialize(command,config_files,options={})
        raise TypeError unless options.kind_of? Hash
        @config_files=config_files
        @command=command.to_s.upcase.to_sym rescue nil
        @options=options
        validate_command
        validate_options
      end

      def execute
        case @command
          when :CONFIGURE
            do_configure
        end
      end

      private

      def validate_command
        raise InvalidCommand, "Invalid command - '#{@command}'"  unless VALID_COMMANDS.include? @command
      end

      def validate_options
        case @command
          when :CONFIGURE
            (raise InvalidOption, 'Password is invalid'  if @options[:password].to_s.empty?) unless @options[:password].nil?
        end
      end

      def do_configure
        options={};
        options[:password]=@options[:password] unless @options[:password].nil?
        a=Alces::IPMIConfigurator::IPMIConfigurator.new(@config_files,options)
        a.set_network
      end

    end
  end
end

begin
  cli=Alces::IPMIConfigurator::CLI::new(command,config_files,{})
  cli.execute
rescue Alces::IPMIConfigurator::CLI::InvalidCommand => e
  STDERR.puts "ERROR: #{e.message}"
  exit 1
rescue Alces::IPMIConfigurator::CLI::InvalidOption => e
  STDERR.puts "ERROR: #{e.message}"
  exit 1
rescue Exception => e
  STDERR.puts "ERROR: #{e.message}"
  exit 1
end


